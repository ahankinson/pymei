PyMEI README

This is a Python library to read/write Music Encoding Initiative (MEI) files. While MEI is usually expressed in XML, this library abstracts the XML representation, parsing the MEI entities into Python objects. This is to allow for alternative representations to be output, e.g., a MEIXML file can be read in and converted to a JSON representation, or vice-versa.

The structure of this module is fairly straightforward. Here is a very brief introduction to the content of the files/folders.

__init__.py
This file holds a lot of the constants for the MEI module. Since this file gets called whenever the module is imported, it sets up many of the required information for dealing with Mei Documents. At the time of this writing, it deals mostly with defining some static namespaces for MEI documents and handles loading the schema for validating MEI output.

Components:
Holds the main MEI objects code. There are three "Base" classes defined: MeiAttribute, MeiDocument and MeiElement. Each of these classes are designed to be used as an base class for the specific MEI element. For example, a theoretical XML file might have the following:

XML:
<document>
    <element some="attribute">
        <nested>Some content</nested>
    </element>
</document>

This segment would be interpreted as Python objects. The MeiDocument is a wrapper to a nested group of MeiElements, each with lists of children tags. In the given example, there would be a Python object for "document," with a child MeiElement called "element," with a further child element "nested." The "element" object would also have a key,value list of attributes, e.g. a Python dictionary:

Python:
{"some": "attribute"}

The "Modules" directory contains element definitions named after all of the MEI elements defined in the spec. These are broken into the same modules defined in the MEI schema for easy location of element definitions. The critical thing to notice is that each class is named after defined elements *except* that the class names all have an appended underscore in the class definition. This is to avoid namespace collisions with built-in Python calls, e.g. "list" refers to a Python list, while "list_" would refer specifically to the MEI <list> element.

Each class is defined almost exactly the same. For example:

Python:
class verse_(MeiElement):
    def __init__(self, value=None, parent=None, **attrs):
        MeiElement.__init__(self, name=u"verse_", value=value, parent=parent)
        if attrs:
            self.setattributes(attrs)
            
This defines the "<verse>" element. You can instantiate it with the following code:

Python:
foo = verse_(value="Some text", lang="english", some="attribute")

This would be exactly equal to the following XML declaration:

XML:
<verse lang="english" some="attribute">
    Some text
</verse>

=============

Export & Import

The design and use of this module depends on the ability to take a nested collection of Python objects and convert them into some textual representation (e.g. XML), or vice-versa: to take a textual representation and turn it into a nested collection of Python objects.

To that extent, the Import & Export functionality is designed to be modular. A person wishing to take a MeiDocument instance and output it as XML might do the following

Python:
from pymei.Export import meitoxml
xmlstring = meitoxml(meidocument)
xmlfile = open('meidoc.xml', 'w')
xmlfile.write(xmlstring)

This may not be the exact way of doing it, but it illustrates that you can take a Python object ("meidocument") and write it out as XML to a file.

Reading in an XML document should work the exact same way in reverse:

Python:
from pymei.Import import xmltomei
xmlfile = open('meidoc.xml', 'r')
xmlstring = xmlfile.read()
meidocument = xmltomei(xmlstring)

Having the module structured this way means you can simply substitute "meitoxml" or "xmltomei" with similar calls to "meitojson" and "jsontomei" and have it function the exact same way. This makes it easy to write converters to input and output other types of documents.

Currently, though, we're focusing just on the XML functionality.

==============

TO DO

Internal representation:

There are plenty of to-dos, but the biggest things are making sure that the Python representations are exactly the same as the XML representations. This is especially critical for maintaining ordering. For example, if you have a sequence of notes

C D E F G A Bb C

And the Python representation doesn't know how to maintain the ordering, you may get

C Bb A G F E D C

as the sequence, or they may be completely out of order. Therefore we need to make sure that we either store the entities in order, or we write some methods to make sure they are output in order. 

Document creation:

Importing already-created MEI files should be fairly straightforward, but a significant part of this library is to help create new, well-formed MEI files. Thus, we'll need to write some functions that allow us to do things like set up an empty MEI document, e.g.

from pymei.Helpers import MeiSkeleton
meidoc = MeiSkeleton()

"meidoc" then becomes a basic MeiDocument, with pre-added sections for the head & body, some basic metadata, etc. We'll also need methods for easily creating common elements, e.g.

meidoc.addelement("note", params)

etc...

Unit Tests:

A big part of this will be writing unit tests, making sure that everything functions according to the way we want it to. A big part of unit testing is just to make sure that, given an input, a method will return an expected output. So, given a very simple method:

def adder(num):
  return num + 1
  
We would write a unit test that calls the adder method with the number 3, and assert that it returns a 4.

Python has a very good unit testing module, http://docs.python.org/library/unittest.html

I can give you a better overview of this in person.



